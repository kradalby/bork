package actions

import (
	"github.com/gobuffalo/buffalo"
	"github.com/gobuffalo/pop"
	"github.com/kradalby/bork/models"
	"github.com/pkg/errors"
)

// This file is generated by Buffalo. It offers a basic structure for
// adding, editing and deleting a page. If your model is more
// complex or you need more than the basic implementation you need to
// edit this file.

// Following naming logic is implemented in Buffalo:
// Model: Singular (User)
// DB Table: Plural (users)
// Resource: Plural (Users)
// Path: Plural (/users)
// View Template Folder: Plural (/templates/users/)

// UsersResource is the resource for the User model
// type UsersResource struct {
// 	buffalo.Resource
// }

// List gets all Users. This function is mapped to the path
// GET /users
func UserList(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return c.Error(500, errors.New("Could not establish database connection"))
	}

	users := &models.Users{}

	// Retrieve all Users from the DB
	if err := tx.Eager().All(users); err != nil {
		return errors.WithStack(err)
	}

	return c.Render(200, r.JSON(users))
}

// Show gets the data for one User. This function is mapped to
// the path GET /users/{user_id}
func UserShow(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return c.Error(500, errors.New("Could not establish database connection"))
	}

	// Allocate an empty User
	user := &models.User{}

	// To find the User the parameter user_id is used.
	if err := tx.Find(user, c.Param("user_id")); err != nil {
		return c.Error(404, errors.New("User not found"))
	}

	return c.Render(200, r.JSON(user))
}

// List gets all Users. This function is mapped to the path
// GET /users/search/{query}
// func UserSearch(c buffalo.Context) error {
// 	// Get the DB connection from the context
// 	tx, ok := c.Value("tx").(*pop.Connection)
// 	if !ok {
// 		return errors.WithStack(errors.New("no transaction found"))
// 	}
//
// 	users := &models.Users{}
//
// 	// Retrieve all Users from the DB
// 	if err := tx.All(users); err != nil {
// 		return errors.WithStack(err)
// 	}
//
// 	results := fuzzy.FindFrom(c.Param("query"), users)
//
// 	filtered := make(&models.Users{}, len(results))
// 	for i
//
// 	return c.Render(200, r.JSON(results))
// }

// // New renders the form for creating a new User.
// // This function is mapped to the path GET /users/new
// func (v UsersResource) New(c buffalo.Context) error {
// 	return c.Render(200, r.JSON(&models.User{}))
// }
//
// // Create adds a User to the DB. This function is mapped to the
// // path POST /users
// func (v UsersResource) Create(c buffalo.Context) error {
// 	// Allocate an empty User
// 	user := &models.User{}
//
// 	// Bind user to the html form elements
// 	if err := c.Bind(user); err != nil {
// 		return errors.WithStack(err)
// 	}
//
// 	// Get the DB connection from the context
// 	tx, ok := c.Value("tx").(*pop.Connection)
// 	if !ok {
// 		return errors.WithStack(errors.New("no transaction found"))
// 	}
//
// 	// Validate the data from the html form
// 	verrs, err := tx.ValidateAndCreate(user)
// 	if err != nil {
// 		return errors.WithStack(err)
// 	}
//
// 	if verrs.HasAny() {
// 		// Make the errors available inside the html template
// 		c.Set("errors", verrs)
//
// 		// Render again the new.html template that the user can
// 		// correct the input.
// 		return c.Render(422, r.JSON(user))
// 	}
//
// 	// If there are no errors set a success message
// 	c.Flash().Add("success", "User was created successfully")
//
// 	// and redirect to the users index page
// 	return c.Render(201, r.JSON(user))
// }
//
// // Edit renders a edit form for a User. This function is
// // mapped to the path GET /users/{user_id}/edit
// func (v UsersResource) Edit(c buffalo.Context) error {
// 	// Get the DB connection from the context
// 	tx, ok := c.Value("tx").(*pop.Connection)
// 	if !ok {
// 		return errors.WithStack(errors.New("no transaction found"))
// 	}
//
// 	// Allocate an empty User
// 	user := &models.User{}
//
// 	if err := tx.Find(user, c.Param("user_id")); err != nil {
// 		return c.Error(404, err)
// 	}
//
// 	return c.Render(200, r.JSON(user))
// }
//
// // Update changes a User in the DB. This function is mapped to
// // the path PUT /users/{user_id}
// func (v UsersResource) Update(c buffalo.Context) error {
// 	// Get the DB connection from the context
// 	tx, ok := c.Value("tx").(*pop.Connection)
// 	if !ok {
// 		return errors.WithStack(errors.New("no transaction found"))
// 	}
//
// 	// Allocate an empty User
// 	user := &models.User{}
//
// 	if err := tx.Find(user, c.Param("user_id")); err != nil {
// 		return c.Error(404, err)
// 	}
//
// 	// Bind User to the html form elements
// 	if err := c.Bind(user); err != nil {
// 		return errors.WithStack(err)
// 	}
//
// 	verrs, err := tx.ValidateAndUpdate(user)
// 	if err != nil {
// 		return errors.WithStack(err)
// 	}
//
// 	if verrs.HasAny() {
// 		// Make the errors available inside the html template
// 		c.Set("errors", verrs)
//
// 		// Render again the edit.html template that the user can
// 		// correct the input.
// 		return c.Render(422, r.JSON(user))
// 	}
//
// 	// If there are no errors set a success message
// 	c.Flash().Add("success", "User was updated successfully")
//
// 	// and redirect to the users index page
// 	return c.Render(200, r.JSON(user))
// }
//
// // Destroy deletes a User from the DB. This function is mapped
// // to the path DELETE /users/{user_id}
// func (v UsersResource) Destroy(c buffalo.Context) error {
// 	// Get the DB connection from the context
// 	tx, ok := c.Value("tx").(*pop.Connection)
// 	if !ok {
// 		return errors.WithStack(errors.New("no transaction found"))
// 	}
//
// 	// Allocate an empty User
// 	user := &models.User{}
//
// 	// To find the User the parameter user_id is used.
// 	if err := tx.Find(user, c.Param("user_id")); err != nil {
// 		return c.Error(404, err)
// 	}
//
// 	if err := tx.Destroy(user); err != nil {
// 		return errors.WithStack(err)
// 	}
//
// 	// If there are no errors set a flash message
// 	c.Flash().Add("success", "User was destroyed successfully")
//
// 	// Redirect to the users index page
// 	return c.Render(200, r.JSON(user))
// }
